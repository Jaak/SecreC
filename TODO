

leakage analysis:
. a não aplicação de nenhuma função não esconde: warning
. especificação de leakage que aceita tudo menos a identidade, derivada automaticamente
. probabilistic leakage: e.g., randomizar os elementos de uma lista esconde as comparações

no implicit public -> private conversion for templates
public domain by default, dimensionality is 0
in SecreC templates are not typechecked unless instantiated

research contributions:
leakage analysis
probabilistic knowledge inference?


o que acontece se uma operação leakar, por exemplo, uma comparação implicitamente mas essa comparação não surgir como uma variável?? Talvez um passo de simplificação prévio resolva isto... assumindo que a informação leakável é aquela que pode ser deduzida a partir das operações primitivas. Por exemplo, se uma variável for conhecida em todos os traces menos um, essa informação conhecida não é considerada leakada.


applications for random ; sort: RSA exponentiation?

most possibly controversial typechecker decisions:
. consts
. promote sizes to the type-level
. literal coercions
. template resolution algorithm:
    - templates raise constraints that are only solved on instantiation (akin to Haskell typeclass constraints)
    - regular procedures and structs solve constraints 
. variadic arguments
. templates work like type classes, e.g., mutually recursive type classes may loop indefinitely
. non-template procedure and structs  may be recursive, but not mutually recursive, since they require all declarations to be defined above.

TODO:
. SMT overflow semantics versus sharemind primitive operations?
. index expression semantics is independent from expression semantics; invariants, dimensions and sizes are evaluated as index conditions and expressions, apart from the regular template-based semantics
. idea: simplify expressions and convert canonical SecreC into index expressions
. procedure template parameters
. size-dependent types
. pre-processor options in SecreC files with hyphens are not recognized. no idea why

template <domain D, type T, dim N>
D T[[1]](n) reshape (D T[[N]] arr ,uint n) {
    // stub
    assert (size(arr) == n);
    D T[[1]] ret (n);
    return ret;
}

. add template constraints, e.g., D T [[N]], N > 0

template <domain D, dim N, N > 0>
D bool[[N]] operator && (D bool[[N]] x,D bool[[N]] y) {
    //stub
    D bool[[N]] ret;
    D bool z;
    // simply to enforce the T operator + (T,T) constraint
    z = z && z;
    return ret;
}






