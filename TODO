

leakage analysis:
. a não aplicação de nenhuma função não esconde: warning
. especificação de leakage que aceita tudo menos a identidade, derivada automaticamente
. probabilistic leakage: e.g., randomizar os elementos de uma lista esconde as comparações

no implicit public -> private conversion for templates
public domain by default, dimensionality is 0
in SecreC templates are not typechecked unless instantiated

research contributions:
leakage analysis
probabilistic knowledge inference?


o que acontece se uma operação leakar, por exemplo, uma comparação implicitamente mas essa comparação não surgir como uma variável?? Talvez um passo de simplificação prévio resolva isto...


applications for random ; sort: RSA exponentiation?

most possibly controversial typechecker decisions:
. promote sizes to the type-level
. literal coercions
. template resolution algorithm:
    - templates raise constraints that are only solved on instantiation (akin to Haskell typeclass constraints)
    - regular procedures and structs solve constraints 

TODO:
. assignments must remove hypothesis over variables
. index expression semantics is independent from expression semantics
. delayed expr2IExpr conversion
. procedure template parameters
. size-dependent types

template <domain D, type T, dim N>
D T[[1]](n) reshape (D T[[N]] arr ,uint n) {
    // stub
    assert (size(arr) == n);
    D T[[1]] ret (n);
    return ret;
}

. add template constraints, e.g., D T [[N]], N > 0

template <domain D, dim N, N > 0>
D bool[[N]] operator && (D bool[[N]] x,D bool[[N]] y) {
    //stub
    D bool[[N]] ret;
    D bool z;
    // simply to enforce the T operator + (T,T) constraint
    z = z && z;
    return ret;
}






