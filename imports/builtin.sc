module builtin;
    
// casts

// to bool
bool operator (bool) (bool x) {
    return x;
}
bool operator (bool) (uint8 x) {
    bool ret;
    return ret;
}
bool operator (bool) (uint16 x) {
    bool ret;
    return ret;
}
bool operator (bool) (uint32 x) {
    bool ret;
    return ret;
}
bool operator (bool) (uint64 x) {
    bool ret;
    return ret;
}
bool operator (bool) (int8 x) {
    bool ret;
    return ret;
}
bool operator (bool) (int16 x) {
    bool ret;
    return ret;
}
bool operator (bool) (int32 x) {
    bool ret;
    return ret;
}
bool operator (bool) (int64 x) {
    bool ret;
    return ret;
}
bool operator (bool) (float32 x) {
    bool ret;
    return ret;
}
bool operator (bool) (float64 x) {
    bool ret;
    return ret;
}

// to uint8
uint8 operator (uint8) (bool x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (uint8 x) {
    return x;
}
uint8 operator (uint8) (uint16 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (uint32 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (uint64 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (int8 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (int16 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (int32 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (int64 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (float32 x) {
    uint8 ret;
    return ret;
}
uint8 operator (uint8) (float64 x) {
    uint8 ret;
    return ret;
}

// to uint16
uint16 operator (uint16) (bool x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (uint8 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (uint16 x) {
    return x;
}
uint16 operator (uint16) (uint32 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (uint64 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (int8 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (int16 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (int32 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (int64 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (float32 x) {
    uint16 ret;
    return ret;
}
uint16 operator (uint16) (float64 x) {
    uint16 ret;
    return ret;
}

// to uint32
uint32 operator (uint32) (bool x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (uint8 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (uint16 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (uint32 x) {
    return x;
}
uint32 operator (uint32) (uint64 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (int8 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (int16 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (int32 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (int64 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (float32 x) {
    uint32 ret;
    return ret;
}
uint32 operator (uint32) (float64 x) {
    uint32 ret;
    return ret;
}

// to uint64
uint64 operator (uint64) (bool x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (uint8 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (uint16 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (uint32 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (uint64 x) {
    return x;
}
uint64 operator (uint64) (int8 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (int16 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (int32 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (int64 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (float32 x) {
    uint64 ret;
    return ret;
}
uint64 operator (uint64) (float64 x) {
    uint64 ret;
    return ret;
}

// to int8
int8 operator (int8) (bool x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (uint8 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (uint16 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (uint32 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (uint64 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (int8 x) {
    return x;
}
int8 operator (int8) (int16 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (int32 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (int64 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (float32 x) {
    int8 ret;
    return ret;
}
int8 operator (int8) (float64 x) {
    int8 ret;
    return ret;
}

// to int16
int16 operator (int16) (bool x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (uint8 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (uint16 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (uint32 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (uint64 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (int8 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (int16 x) {
    return x;
}
int16 operator (int16) (int32 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (int64 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (float32 x) {
    int16 ret;
    return ret;
}
int16 operator (int16) (float64 x) {
    int16 ret;
    return ret;
}

// to int32
int32 operator (int32) (bool x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (uint8 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (uint16 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (uint32 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (uint64 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (int8 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (int16 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (int32 x) {
    return x;
}
int32 operator (int32) (int64 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (float32 x) {
    int32 ret;
    return ret;
}
int32 operator (int32) (float64 x) {
    int32 ret;
    return ret;
}

// to int64
int64 operator (int64) (bool x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (uint8 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (uint16 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (uint32 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (uint64 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (int8 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (int16 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (int32 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (int64 x) {
    return x;
}
int64 operator (int64) (float32 x) {
    int64 ret;
    return ret;
}
int64 operator (int64) (float64 x) {
    int64 ret;
    return ret;
}

// to float32
float32 operator (float32) (bool x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (uint8 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (uint16 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (uint32 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (uint64 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (int8 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (int16 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (int32 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (int64 x) {
    float32 ret;
    return ret;
}
float32 operator (float32) (float32 x) {
    return x;
}
float32 operator (float32) (float64 x) {
    float32 ret;
    return ret;
}

// to float64
float64 operator (float64) (bool x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (uint8 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (uint16 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (uint32 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (uint64 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (int8 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (int16 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (int32 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (int64 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (float32 x) {
    float64 ret;
    return ret;
}
float64 operator (float64) (float64 x) {
    return x;
}

// array casts
template <domain D,dim N,type X,type Y>
D Y[[N]] operator (Y) (D X[[N]] x) {
    //stub
    D Y[[N]] ret;
    D X y;
    D Y z;
    z = (Y) y;
    return ret;
}

// classify
template <domain D,type T,dim N>
D T[[N]] classify (public T[[N]] x) {
    D T[[N]] ret;
    public T x1;
    D T x2 = classify(x1);
    return ret;
}

// declassify
template <domain D,type T,dim N>
public T[[N]] declassify (D T[[N]] x) {
    public T[[N]] ret;
    D T x1;
    public T x2 = declassify(x1);
    return ret;
}

// strlen

uint strlen (string str) {
    //stub
    uint ret;
    return ret;
}

// tostring

template <type T>
string tostring (public T x) {
    //stub
    string ret;
    return ret;
}

// shape

template <domain D, type T, dim N>
uint[[1]] shape (D T[[N]] arr) {
    //stub
    uint[[1]] ret;
    return ret;
}

//cat

template <domain D, type T, dim N>
D T[[N]] cat (D T[[N]] x, D T[[N]] y) {
    D T[[N]] ret;
    return ret;
}

template <domain D, type T, dim N>
D T[[N]] cat (D T[[N]] x, D T[[N]] y, uint n) {
    D T[[N]] ret;
    return ret;
}

// reshape
// TODO: make this a variadic function for an arbitrary number of dimensions?

template <domain D, type T, dim N>
D T[[1]] reshape (D T[[N]] arr,uint n) {
    // stub
    D T[[1]] ret;
    assert (size(arr) == n);
    return ret;
}

template <domain D, type T, dim N>
D T[[2]] reshape (D T[[N]] inp,uint n, uint m) {
    // stub
    D T[[2]] ret;
    assert (size(inp) == n * m);
    return ret;
}

// size

template <domain D, type T, dim N>
uint size (D T[[N]] x) {
    //stub
    public uint ret;
    return ret;
}

// logical operators

bool operator && (bool x,bool y) {
    // stub
    bool ret;
    return ret;
}

template <domain D, dim N>
D bool[[N]] operator && (D bool[[N]] x,D bool[[N]] y) {
    //stub
    D bool[[N]] ret;
    D bool z;
    // simply to enforce the T operator + (T,T) constraint
    z = z && z;
    return ret;
}

bool operator || (bool x,bool y) {
    // stub
    bool ret;
    return ret;
}

template <domain D, dim N>
D bool[[N]] operator || (D bool[[N]] x,D bool[[N]] y) {
    //stub
    D bool [[N]] ret;
    D bool z;
    // simply to enforce the T operator + (T,T) constraint
    z = z || z;
    return ret;
}

bool operator ! (bool x) {
    //stub
    bool ret;
    return ret;
}

template <domain D, dim N>
D bool[[N]] operator ! (D bool[[N]] x) {
    D bool[[N]] ret;
    D bool z;
    z = !z;
    return ret;
}

// unary subtraction

int8 operator - (int8 x) {
    //stub
    int8 ret;
    return ret;
} 
int16 operator - (int16 x) {
    //stub
    int16 ret;
    return ret;
} 
int32 operator - (int32 x) {
    //stub
    int32 ret;
    return ret;
} 
int64 operator - (int64 x) {
    //stub
    int64 ret;
    return ret;
}

// unary array subtraction

template <domain D, type T, dim N>
D T[[N]] operator - (D T[[N]] x) {
    //stub
    D T [[N]] ret;
    D T z;
    // simply to enforce the T operator + (T,T) constraint
    z = - z;
    return ret;
}

// subtraction

int8 operator - (int8 x,int8 y) {
    int8 ret;
    __syscall("haskell.sub_int8",x,y,__return ret);
    return ret;
} 
int16 operator - (int16 x,int16 y) {
    int16 ret;
    __syscall("haskell.sub_int16",x,y,__return ret);
    return ret;
} 
int32 operator - (int32 x,int32 y) {
    int32 ret;
    __syscall("haskell.sub_int32",x,y,__return ret);
    return ret;
} 
int64 operator - (int64 x,int64 y) {
    int64 ret;
    __syscall("haskell.sub_int64",x,y,__return ret);
    return ret;
}
uint8 operator - (uint8 x,uint8 y) {
    uint8 ret;
    __syscall("haskell.sub_uint8",x,y,__return ret);
    return ret;
} 
uint16 operator - (uint16 x,uint16 y) {
    uint16 ret;
    __syscall("haskell.sub_uint16",x,y,__return ret);
    return ret;
} 
uint32 operator - (uint32 x,uint32 y) {
    uint32 ret;
    __syscall("haskell.sub_uint32",x,y,__return ret);
    return ret;
} 
uint64 operator - (uint64 x,uint64 y) {
    uint64 ret;
    __syscall("haskell.sub_uint64",x,y,__return ret);
    return ret;
} 
float32 operator - (float32 x,float32 y) {
    float32 ret;
    __syscall("haskell.sub_float32",x,y,__return ret);
    return ret;
} 
float64 operator - (float64 x,float64 y) {
    float64 ret;
    __syscall("haskell.sub_float64",x,y,__return ret);
    return ret;
} 

// array subtraction

template <domain D, type T, dim N>
D T[[N]] operator - (D T[[N]] x,D T[[N]] y) {
    //stub
    D T [[N]] ret;
    D T z;
    // simply to enforce the T operator + (T,T) constraint
    z = z - z;
    return ret;
}


// addition

int8 operator + (int8 x,int8 y) {
    int8 ret;
    __syscall("haskell.add_int8",x,y,__return ret);
    return ret;
} 
int16 operator + (int16 x,int16 y) {
    int16 ret;
    __syscall("haskell.add_int16",x,y,__return ret);
    return ret;
} 
int32 operator + (int32 x,int32 y) {
    int32 ret;
    __syscall("haskell.add_int32",x,y,__return ret);
    return ret;
} 
int64 operator + (int64 x,int64 y) {
    int64 ret;
    __syscall("haskell.add_int64",x,y,__return ret);
    return ret;
}
uint8 operator + (uint8 x,uint8 y) {
    uint8 ret;
    __syscall("haskell.add_uint8",x,y,__return ret);
    return ret;
} 
uint16 operator + (uint16 x,uint16 y) {
    uint16 ret;
    __syscall("haskell.add_uint16",x,y,__return ret);
    return ret;
} 
uint32 operator + (uint32 x,uint32 y) {
    uint32 ret;
    __syscall("haskell.add_uint32",x,y,__return ret);
    return ret;
} 
uint64 operator + (uint64 x,uint64 y) {
    uint64 ret;
    __syscall("haskell.add_uint64",x,y,__return ret);
    return ret;
} 
float32 operator + (float32 x,float32 y) {
    float32 ret;
    __syscall("haskell.add_float32",x,y,__return ret);
    return ret;
} 
float64 operator + (float64 x,float64 y) {
    float64 ret;
    __syscall("haskell.add_float64",x,y,__return ret);
    return ret;
} 

// array addition

template <domain D, type T, dim N>
D T[[N]] operator + (D T[[N]] x,D T[[N]] y) {
    //stub
    D T [[N]] ret;
    D T z;
    // simply to enforce the T operator + (T,T) constraint
    z = z + z;
    return ret;
}

// multiplication

int8 operator * (int8 x,int8 y) {
    //stub
    int8 ret;
    return ret;
} 
int16 operator * (int16 x,int16 y) {
    //stub
    int16 ret;
    return ret;
} 
int32 operator * (int32 x,int32 y) {
    //stub
    int32 ret;
    return ret;
} 
int64 operator * (int64 x,int64 y) {
    //stub
    int64 ret;
    return ret;
}
uint8 operator * (uint8 x,uint8 y) {
    //stub
    uint8 ret;
    return ret;
} 
uint16 operator * (uint16 x,uint16 y) {
    //stub
    uint16 ret;
    return ret;
} 
uint32 operator * (uint32 x,uint32 y) {
    //stub
    uint32 ret;
    return ret;
} 
uint64 operator * (uint64 x,uint64 y) {
    //stub
    uint64 ret;
    return ret;
} 
float32 operator * (float32 x,float32 y) {
    //stub
    float32 ret;
    return ret;
} 
float64 operator * (float64 x,float64 y) {
    //stub
    float64 ret;
    return ret;
} 

// array multiplication

template <domain D, type T, dim N>
D T[[N]] operator * (D T[[N]] x,D T[[N]] y) {
    //stub
    D T [[N]] ret;
    D T z;
    // simply to enforce the T operator + (T,T) constraint
    z = z * z;
    return ret;
}


// division

int8 operator / (int8 x,int8 y) {
    //stub
    int8 ret;
    return ret;
} 
int16 operator / (int16 x,int16 y) {
    //stub
    int16 ret;
    return ret;
} 
int32 operator / (int32 x,int32 y) {
    //stub
    int32 ret;
    return ret;
} 
int64 operator / (int64 x,int64 y) {
    //stub
    int64 ret;
    return ret;
}
uint8 operator / (uint8 x,uint8 y) {
    //stub
    uint8 ret;
    return ret;
} 
uint16 operator / (uint16 x,uint16 y) {
    //stub
    uint16 ret;
    return ret;
} 
uint32 operator / (uint32 x,uint32 y) {
    //stub
    uint32 ret;
    return ret;
} 
uint64 operator / (uint64 x,uint64 y) {
    //stub
    uint64 ret;
    return ret;
} 
float32 operator / (float32 x,float32 y) {
    //stub
    float32 ret;
    return ret;
} 
float64 operator / (float64 x,float64 y) {
    //stub
    float64 ret;
    return ret;
} 

// array division

template <domain D, type T, dim N>
D T[[N]] operator / (D T[[N]] x,D T[[N]] y) {
    //stub
    D T [[N]] ret;
    D T z;
    // simply to enforce the T operator + (T,T) constraint
    z = z / z;
    return ret;
}

// modulo

int8 operator % (int8 x,int8 y) {
    //stub
    int8 ret;
    return ret;
} 
int16 operator % (int16 x,int16 y) {
    //stub
    int16 ret;
    return ret;
} 
int32 operator % (int32 x,int32 y) {
    //stub
    int32 ret;
    return ret;
} 
int64 operator % (int64 x,int64 y) {
    //stub
    int64 ret;
    return ret;
}
uint8 operator % (uint8 x,uint8 y) {
    //stub
    uint8 ret;
    return ret;
} 
uint16 operator % (uint16 x,uint16 y) {
    //stub
    uint16 ret;
    return ret;
} 
uint32 operator % (uint32 x,uint32 y) {
    //stub
    uint32 ret;
    return ret;
} 
uint64 operator % (uint64 x,uint64 y) {
    //stub
    uint64 ret;
    return ret;
} 
float32 operator % (float32 x,float32 y) {
    //stub
    float32 ret;
    return ret;
} 
float64 operator % (float64 x,float64 y) {
    //stub
    float64 ret;
    return ret;
} 

// array modulo

template <domain D, type T, dim N>
D T[[N]] operator % (D T[[N]] x,D T[[N]] y) {
    //stub
    D T [[N]] ret;
    D T z;
    // simply to enforce the T operator + (T,T) constraint
    z = z % z;
    return ret;
}

// greater

bool operator > (int8 x,int8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (int16 x,int16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (int32 x,int32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (int64 x,int64 y) {
    //stub
    bool ret;
    return ret;
}
bool operator > (uint8 x,uint8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (uint16 x,uint16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (uint32 x,uint32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (uint64 x,uint64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (float32 x,float32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (float64 x,float64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator > (bool x,bool y) {
    //stub
    bool ret;
    return ret;
} 

// array greater

template <domain D, type T, dim N>
D bool[[N]] operator > (D T[[N]] x,D T[[N]] y) {
    //stub
    D bool [[N]] ret;
    D T z;
    D bool b;
    // simply to enforce the T operator + (T,T) constraint
    b = z > z;
    return ret;
}

// smaller

bool operator < (int8 x,int8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (int16 x,int16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (int32 x,int32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (int64 x,int64 y) {
    //stub
    bool ret;
    return ret;
}
bool operator < (uint8 x,uint8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (uint16 x,uint16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (uint32 x,uint32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (uint64 x,uint64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (float32 x,float32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (float64 x,float64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator < (bool x,bool y) {
    //stub
    bool ret;
    return ret;
} 

// array smaller

template <domain D, type T, dim N>
D bool[[N]] operator < (D T[[N]] x,D T[[N]] y) {
    //stub
    D bool [[N]] ret;
    D T z;
    D bool b;
    // simply to enforce the T operator + (T,T) constraint
    b = z < z;
    return ret;
}

// greater or equal

bool operator >= (int8 x,int8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (int16 x,int16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (int32 x,int32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (int64 x,int64 y) {
    //stub
    bool ret;
    return ret;
}
bool operator >= (uint8 x,uint8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (uint16 x,uint16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (uint32 x,uint32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (uint64 x,uint64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (float32 x,float32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (float64 x,float64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator >= (bool x,bool y) {
    //stub
    bool ret;
    return ret;
} 

// array greater or equal

template <domain D, type T, dim N>
D bool[[N]] operator >= (D T[[N]] x,D T[[N]] y) {
    //stub
    D bool [[N]] ret;
    D T z;
    D bool b;
    // simply to enforce the T operator + (T,T) constraint
    b = z >= z;
    return ret;
}

// smaller or equal

bool operator <= (int8 x,int8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (int16 x,int16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (int32 x,int32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (int64 x,int64 y) {
    //stub
    bool ret;
    return ret;
}
bool operator <= (uint8 x,uint8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (uint16 x,uint16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (uint32 x,uint32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (uint64 x,uint64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (float32 x,float32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (float64 x,float64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator <= (bool x,bool y) {
    //stub
    bool ret;
    return ret;
} 

// array greater

template <domain D, type T, dim N>
D bool[[N]] operator <= (D T[[N]] x,D T[[N]] y) {
    //stub
    D bool [[N]] ret;
    D T z;
    D bool b;
    // simply to enforce the T operator + (T,T) constraint
    b = z <= z;
    return ret;
}

// equal

bool operator == (int8 x,int8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (int16 x,int16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (int32 x,int32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (int64 x,int64 y) {
    //stub
    bool ret;
    return ret;
}
bool operator == (uint8 x,uint8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (uint16 x,uint16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (uint32 x,uint32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (uint64 x,uint64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (float32 x,float32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (float64 x,float64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator == (bool x,bool y) {
    //stub
    bool ret;
    return ret;
} 

// array greater

template <domain D, type T, dim N>
D bool[[N]] operator == (D T[[N]] x,D T[[N]] y) {
    //stub
    D bool [[N]] ret;
    D T z;
    D bool b;
    // simply to enforce the T operator + (T,T) constraint
    b = z == z;
    return ret;
}

// not equal

bool operator != (int8 x,int8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (int16 x,int16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (int32 x,int32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (int64 x,int64 y) {
    //stub
    bool ret;
    return ret;
}
bool operator != (uint8 x,uint8 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (uint16 x,uint16 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (uint32 x,uint32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (uint64 x,uint64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (float32 x,float32 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (float64 x,float64 y) {
    //stub
    bool ret;
    return ret;
} 
bool operator != (bool x,bool y) {
    //stub
    bool ret;
    return ret;
} 

// array greater

template <domain D, type T, dim N>
D bool[[N]] operator != (D T[[N]] x,D T[[N]] y) {
    //stub
    D bool [[N]] ret;
    D T z;
    D bool b;
    // simply to enforce the T operator + (T,T) constraint
    b = z != z;
    return ret;
}